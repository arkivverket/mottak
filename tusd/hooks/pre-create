#!/usr/bin/env python3
import os                               # for getenv
import sys
import json
import psycopg2
import psycopg2.extras
import psycopg2.errors
import string
import subprocess
# For python 3.6
from subprocess import PIPE
import re  # for parsing the DBSTRING

import logging

from azure.servicebus import QueueClient, Message
from azure.servicebus.common.constants import ReceiveSettleMode
try:
    from dotenv import load_dotenv
    load_dotenv()
except:
    print('dotenv not loaded')

# Todo: check that the uploader URL has not been tampered with - add some crypto
# Todo: improve error handling.
# Todo: this should have tests.

# Return codes.
UUIDERROR = 1    # invalid UUID
DBERROR = 10     #
JSONERROR = 11   # JSON parsing
IOERROR = 12
USAGEERROR = 13  # some sort of user error.
ARGOERROR = 14   # no in use anymore
UNKNOWNUUID = 15  # unknown UUID
UNKNOWNIID = 16  # unknown invitation
SBERROR = 17


def create_db_access(dbstring):
    """Create a psycopg2 compatible object from the connection string.
    The string is from PHP and we reuse it here
    """
    mystr = dbstring[6:]
    mystr = mystr.rstrip()
    d = dict(re.findall(r'(\w+)=([^;]+);?', mystr))
    # Validate dbstring:
    for key in ['user', 'password', 'host', 'dbname']:
        if key not in d.keys():
            logging.error('%s not found in DBSTRING' % key)
            raise ValueError
    return d


def my_connect(conn_info):
    try:
        connection = psycopg2.connect(user=conn_info['user'],
                                      host=conn_info['host'],
                                      dbname=conn_info['dbname'],
                                      password=conn_info['password'],
                                      sslmode='require',
                                      # Thank you azure (only needed outside Azure):
                                      sslrootcert='BaltimoreCyberTrustRoot.crt.pem',
                                      connect_timeout=10)
    except (Exception, psycopg2.Error) as error:
        logging.error(f"Error while connecting to PostgreSQL: {error}")
        raise(error)
    finally:
        return connection


def my_disconnect(conn):
    conn.close()


def read_tusd_event(step):
    """ _ stdin and parse the JSON object. Step is given for error reporting.
    Returns a dict based on the JSON input given"""
    try:
        data = json.load(sys.stdin)
    except Exception as ex:
        raise(ex)
    # Enable this when debugging the events. It dumps the input to /tmp so you can re-run the hook with stdin.
    try:
        with open(f'/tmp/json-event-{step}.json', 'w') as event_file:
            json.dump(data, event_file, sort_keys=True, indent=4)
    except Exception as exception:
        logging.error(f'Error while dumping JSON: {exception}')
        # Not really a fatal error. We can continue.
    return data


def get_metadata(conn, invitation_id):
    """ Fetch metadata about an invitation from the database using the invitation id as key """
    try:
        dict_cursor = conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor)
        dict_cursor.execute('SELECT invitations.id, uuid, checksum, is_sensitive, name, email, type '
                            'FROM invitations, archive_types '
                            'WHERE archive_type_id=archive_types.id '
                            'AND invitations.id=%s', (invitation_id))
        rec = dict_cursor.fetchall()
        print(rec)
    except psycopg2.Error as exception:
        logging.error(f'Database error: {exception}')
        exit(DBERROR)

    if len(rec) == 0:
        return None
    else:
        return rec[0]


def update_db_with_objectname(conn, iid, objectname):
    """ Update the database with the name of the relevant object as it is named in the object store.
        We do this as tusd assigns a random name to each object """
    try:
        cur = conn.cursor()
        cur.execute(
            "UPDATE invitations SET object_name = %s WHERE id = %s", (objectname, iid))
        if cur.rowcount != 1:
            raise(psycopg2.DataError)
    except psycopg2.Error as exception:
        logging.error(f'Database error: {exception}')
        raise(exception)


def gather_params(dbdata, data):
    """ create dict with the relevant data from metadata (from DB) and from data (from stdin) """
    # define en workflow parameters
    params = {
        'UUID': dbdata['uuid'],
        'OBJECT': data['Upload']['Storage']['Key'],
        'CHECKSUM': dbdata['checksum'],
        'ARCHIEVE_TYPE': dbdata['type'],
        'NAME': dbdata['name'],
        'EMAIL': dbdata['email'],
        'INVITATIONID': dbdata['id']
    }
    return params


def get_sb_sender(conn_str, queue):
    try:
        queue_client = QueueClient.from_connection_string(
            conn_str, queue)
        return queue_client.get_sender()
    except Exception as exception:
        logging.error(f'Could not connect to Service Bus Queue: {exception}')
        logging.error(f'Connection string: {conn_str}')   # Todo: Potential security issue here. Filter out parts of the string?
        logging.error(f'Queue: {queue}')
        exit(SBERROR)


def argo_submit(params):
    """ Submit a job to argo. Takes a dict with parameters. """
    conn_str = os.getenv('AZ_SB_CON_KICKER')
    queue = os.getenv('AZ_SB_QUEUE')
    message = {
        'action': 'argo-submit',
        'params': params,
    }
    qsender = get_sb_sender(conn_str, queue)
    with qsender:
        try:
            message = Message(json.dumps(message).encode('utf8'))
            logging.info(f'Sending message: {message}')
            ret = qsender.send(message)
        except Exception as exception:
            logging.error(
                f'Failed to send message over service bus: {exception}')
            exit(SBERROR)


# Todo: refactor, this is pretty long and ugly.
def main():
    logging.basicConfig(level=os.getenv('LOGLEVEL', 'INFO'))
    # Silence the overly verbose service bus lib:
    logging.getLogger("uamqp").setLevel(logging.WARNING)

    hook_name = os.path.basename(__file__)
    logging.info(f'hook running as {hook_name}')
    # parse json on stdin into this structure.
    try:
        tusd_data = read_tusd_event(step=hook_name)
    except Exception as exception:
        logging.error(exception)
        exit(JSONERROR)
    if not tusd_data:
        logging.error("Could not read tusd event.")
        exit(JSONERROR)

    if not (os.getenv('DBSTRING')):
        logging.error("DBSTRING environment variable not set")
        exit(USAGEERROR)

    try:
        iid = tusd_data["Upload"]["MetaData"]["invitation_id"]
        logging.info(f"Invitation ID from JSON: {iid}")
        # todo: Specify exception.
    except:
        logging.error(f"Could not find invitation_id in JSON: {iid}")
        exit(UNKNOWNIID)

    connection = my_connect(create_db_access(os.getenv('DBSTRING')))
    metadata = get_metadata(connection, iid)
    if (metadata == None):
        logging.error(
            f"Failed to fetch metadata for invitation {iid} - no invitation?")
        exit(UNKNOWNIID)

    try:
        uuid = metadata['uuid']
    except Exception as exception:
        logging.error(
            f'Error while looking up uuid from invition ({iid}) from DB: {exception}')
        exit(UNKNOWNIID)

    # This is the pre-create hook. The only concern here is to validate the UUID
    if (hook_name == 'pre-create'):
        if (uuid == metadata['uuid']):
            logging.info('Invitation ID verified.')
            exit(0)
        else:
            logging.error(
                f'UUID mismatch (from DB:{metadata["uuid"]} - from tusd: {uuid}')
            logging.error("Aborting")
            exit(UUIDERROR)
    elif (hook_name == 'post-finish'):
        # We assume that we're the post-create hook and we create an input-file for argo
        # and submit the workflow into argo.

        # Verify that we have a filename:
        try:
            filename = tusd_data['Upload']['Storage']['Key']
            logging.debug(f"File name (in objectstore) is {filename}")
        except:
            logging.error("Could not key/filename in JSON. Dumping JSON:")
            logging.error(json.dumps(tusd_data, indent=4, sort_keys=True))
            exit(JSONERROR)

        try:
            update_db_with_objectname(connection, iid, filename)
            logging.debug(
                f"Set object_name to {filename} for iid {iid} in database.")
        except Exception as exception:
            logging.error("Error while updating database {exception}")
            exit(DBERROR)

        if ((metadata) and ('uuid' in metadata)):
            params = gather_params(metadata, tusd_data)
            argo_submit(params)
            my_disconnect(connection)
            exit(0)
        else:
            logging.error("Unknown UUID:" + uuid)
            exit(UUIDERROR)
    else:
        logging.error(f'Unsupported hook: {hook_name}')
        exit(USAGEERROR)

    ########################################################
    ############# Run from here  ###########################
    ########################################################


if __name__ == "__main__":
    main()
